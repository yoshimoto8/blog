{"ast":null,"code":"import path from \"path\";\nimport remark from \"remark\";\nimport html from \"remark-html\";\nimport matter from \"gray-matter\";\nimport { formatDate } from \"./date\";\nconst DIR = path.join(process.cwd(), \"content/posts\");\nconst EXTENSION = \".md\";\n/**\n * Markdown のファイル一覧を取得する\n */\n\nconst listContentFiles = ({\n  fs\n}) => {\n  const filenames = fs.readdirSync(DIR);\n  return filenames.filter(filename => path.parse(filename).ext === EXTENSION);\n};\n/**\n * Markdown のファイルの中身を全件パースして取得する\n */\n\n\nconst readContentFiles = async ({\n  fs\n}) => {\n  const promisses = listContentFiles({\n    fs\n  }).map(filename => readContentFile({\n    fs,\n    filename\n  }));\n  const contents = await Promise.all(promisses);\n  return contents.sort(sortWithProp('published', true));\n};\n/**\n * Markdown のファイルの中身をパースして取得する\n */\n\n\nconst readContentFile = async ({\n  fs,\n  slug,\n  filename\n}) => {\n  if (slug === undefined) {\n    slug = path.parse(filename).name;\n  }\n\n  const raw = fs.readFileSync(path.join(DIR, `${slug}${EXTENSION}`), 'utf8');\n  const matterResult = matter(raw);\n  const {\n    title,\n    published: rawPublished\n  } = matterResult.data;\n  const parsedContent = await remark().use(html).use(() => genAttrsAdder(\"image\", {\n    loading: \"lazy\"\n  })).process(matterResult.content);\n  const content = parsedContent.toString();\n  return {\n    title,\n    published: formatDate(rawPublished),\n    content,\n    slug\n  };\n};\n/**\n * Markdown の投稿をソートするためのヘルパー\n */\n\n\nconst sortWithProp = (name, reversed) => (a, b) => {\n  if (reversed) {\n    return a[name] < b[name] ? 1 : -1;\n  } else {\n    return a[name] < b[name] ? -1 : 1;\n  }\n};\n/**\n * 指定された node attributes を追加する remark プロセッサ\n */\n\n\nconst genAttrsAdder = (type, attrs) => {\n  return transformer;\n\n  function transformer(node) {\n    if (node.type === type) {\n      node.data = node.data || {};\n      node.data.hProperties = Object.assign({}, node.data.hProperties, attrs);\n    }\n\n    if (node.children) {\n      node.children.map(child => transformer(child));\n    }\n  }\n};\n\nexport { listContentFiles, readContentFiles, readContentFile };","map":{"version":3,"sources":["/Users/yoshimotokoki/project/blog/lib/content-loader.js"],"names":["path","remark","html","matter","formatDate","DIR","join","process","cwd","EXTENSION","listContentFiles","fs","filenames","readdirSync","filter","filename","parse","ext","readContentFiles","promisses","map","readContentFile","contents","Promise","all","sort","sortWithProp","slug","undefined","name","raw","readFileSync","matterResult","title","published","rawPublished","data","parsedContent","use","genAttrsAdder","loading","content","toString","reversed","a","b","type","attrs","transformer","node","hProperties","Object","assign","children","child"],"mappings":"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","sourcesContent":["import path from \"path\"\n\nimport remark from \"remark\"\nimport html from \"remark-html\"\nimport matter from \"gray-matter\"\n\nimport { formatDate } from \"./date\"\n\nconst DIR = path.join(process.cwd(), \"content/posts\")\nconst EXTENSION = \".md\"\n\n/**\n * Markdown のファイル一覧を取得する\n */\nconst listContentFiles = ({ fs }) => {\n  const filenames = fs.readdirSync(DIR)\n  return filenames\n    .filter((filename) => path.parse(filename).ext === EXTENSION)\n}\n\n/**\n * Markdown のファイルの中身を全件パースして取得する\n */\nconst readContentFiles = async ({ fs }) => {\n  const promisses = listContentFiles({ fs })\n    .map((filename) => readContentFile({ fs, filename }))\n\n  const contents = await Promise.all(promisses)\n\n  return contents.sort(sortWithProp('published', true))\n}\n\n/**\n * Markdown のファイルの中身をパースして取得する\n */\nconst readContentFile = async ({ fs, slug, filename }) => {\n  if (slug === undefined) {\n    slug = path.parse(filename).name\n  }\n  const raw = fs.readFileSync(path.join(DIR, `${slug}${EXTENSION}`), 'utf8')\n  const matterResult = matter(raw)\n\n  const { title, published: rawPublished } = matterResult.data\n\n  const parsedContent = await remark()\n    .use(html)\n    .use(() => genAttrsAdder(\"image\", {loading: \"lazy\"}))\n    .process(matterResult.content)\n  const content = parsedContent.toString()\n\n  return {\n    title,\n    published: formatDate(rawPublished),\n    content,\n    slug,\n  }\n}\n\n/**\n * Markdown の投稿をソートするためのヘルパー\n */\nconst sortWithProp = (name, reversed) => (a, b) => {\n  if (reversed) {\n    return a[name] < b[name] ? 1 : -1\n  } else {\n    return a[name] < b[name] ? -1 : 1\n  }\n}\n\n/**\n * 指定された node attributes を追加する remark プロセッサ\n */\nconst genAttrsAdder = (type, attrs) => {\n  return transformer\n\n  function transformer(node) {\n    if (node.type === type) {\n      node.data = node.data || {}\n      node.data.hProperties = Object.assign({}, node.data.hProperties, attrs)\n    }\n\n    if (node.children) {\n      node.children.map((child) => transformer(child))\n    }\n  }\n}\n\nexport { listContentFiles, readContentFiles, readContentFile }\n"]},"metadata":{},"sourceType":"module"}